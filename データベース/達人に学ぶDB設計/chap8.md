## 論理設計のグレーノウハウ

<div style="padding: 10px; margin-bottom: 10px; border: 5px double;">
    <h5>学習のポイント</h5>
    <ul>
        <li>バッドノウハウ以外にも、違法スレスレのグレーノウハウがある。</li>
        <li><font color=red><b>グレーノウハウは用法・用量を守れば「良薬」になるが、利点と欠点のバランスを考える必要がある</b></font>。</li>
        <li>グレーノウハウには代理キー、列持ちテーブル、アドホックな集計キー、多段ビューがある。</li>
    </ul>
</div>

<div style="padding: 10px; margin-bottom: 10px; border: 5px double;">
    <h5>勘どころ</h5>
    <ol start=51>
        <li>シーケンスとID列ではシーケンスの方がより柔軟で拡張性に富む。</li>
        <li>オートナンバリングをアプリケーションで実装するのは「車輪の大発明」。</li>
        <li>ビューの背後にあるテーブルの存在を常に意識する。</li>
        <li>Keep It Simple, Stupid.(KISSの原則)</li>
        <li>一意キーの存在しないデータは「不適切なキー」につながる。</li>
        <li>名寄せをサボると「ダブルマスタ」につながる。</li>
    </ol>
</div>

### 違法スレスレの「ライン上」に位置する設計

システムの世界ではアンチパターンとははっきり断定することことできないものの、無神経に使うと開発や運用に支障をきたすような設計が存在する。本書では具体的に以下のトピックを扱う。

- 代理キー
- 列持ちテーブル
- アドホックな集計キー
- 多段ビュー

<div style="page-break-before:always"></div>

### 代理キー

主キーが決められない、または主キーとして不十分なキーが存在するケースは大きく3つのパターンに分けられる

##### 【パターン1】そもそも入力データに主キーにできるような一意キーが存在しない

**最も単純で言語道断なケース**。テーブル作成の際に一意キーが存在しないため、主キーが決められない状態にある。

##### 【パターン2】一意キーはあるが、サイクリックに使いまわされる

<img src="images/一意キーはあるがサイクリック.png" width=70%>

これは、**主キーの値が全て使われてしまった場合に既存の値が使われるケースで起こる**。例えば、市町村の情報を「A+3桁の数字」で管理している場合で1001個目の市町村を登録するケースを考える。市町村コードを拡張できれば問題ないが、業務ルールによって「すでに廃止された市町村の番号を使い回す」ような選択を余儀なくされることがある。**サイクリックに採番すると運用上問題なくても、<font color=red>データの履歴管理ができないというデメリットがある</font>**。

##### 【パターン3】一意キーはあるが、データの統廃合により途中で対象が変化する

<img src="images/一意キーはあるがデータの統廃合がある.png" width=70%>

パターン3はデータの統廃合に起きる事象であり、パターン2と似た状態になるが発生タイミングが異なる。例えば、レコード1と2のデータを統合する場合、一方のレコードを削除し、もう一方を更新する必要があるが、<font color=red>パターン2と同様、履歴管理ができない</font>。これはデータ統合だけでなく、データ分割の場合でも同様である。

#### 代理キーによる解決

<img src="images/代理キーの解決.png" width=70%>

- **メリット** ①入力仕様とは独立しており業務上の仕様調整を省略できる、②SQLのWHERE句における条件記述をシンプルにできる
- **デメリット** ①代理キーがそもそも論理的に不要なキーである、②ER図から代理キーの役割が分からず論理モデルをわかりにくくする

<div style="page-break-before:always"></div>

#### 自然キーによる解決

時間に関する列を追加し、自然キーによる解決を図る。具体的には**時間を表す列を追加する方法**であり、大きく「タイムスタンプ」と「インターバル」の二種類の方法がある。

##### タイムスタンプ

- **メリット** シンプルでSQLの条件が簡単になる。
- **デメリット** 時間単位(年,月,日,時,分,秒)でフルセット(スナップショット)を用意しないといけず、レコード数が膨大になる。

<img src="images/自然キー_タイムスタンプ.png" width=65%>

```sql
SELECT 市町村コード, 市町村名
FROM 市町村 WHERE タイムスタンプ=2007;
```

##### インターバル

- **メリット** スナップショットが不要になり、全体のレコード数を抑えられ、データ更新が頻繁に発生する場合に効果を発揮する。
- **デメリット** SQLで<u>必ず範囲指定の条件を入れる必要がある</u>。

<img src="images/自然キー_インターバル.png" width=70%>

```sql
SELECT 市町村コード, 市町村名
FROM 2007 BETWEEN 開始年度 AND 終了年度;
```

#### 【コラム】主キーはなぜ必要なのか？

1. **主キーがないと重複を許すことになる。**
2. <font color=red>重複があるとDISTINCT(重複をなくすコマンド)を使うことになり、パフォーマンスに悪影響を与える</font>。
3. <font color=red>重複があると結合処理のコストが高まり、パフォーマンスに悪影響を与える</font>。

### 列持ちテーブル

- <font color=red><b>最初は拡張性の高い行持ちテーブル</b>でデータを保持し、パフォーマンス上の問題でどうしても列持ちテーブルが必要になった場合に、列持ちテーブルを作る。</font>

#### 列持ち(横持ち)テーブル

- **メリット**
  - シンプルな設計
  - 入出力のフォーマットと合わせやすい
- **デメリット**
  - 列の増減が難しい
  - 無用のNULLを使わなくてはならない

<table>
    <caption>扶養者(列持ち)</caption>
	<tbody>
		<tr>
			<th><u>社員ID</th>
			<th>社員名</th>
			<th>子1</th>
			<th>子2</th>
			<th>子3</th>
		</tr>
		<tr>
			<td>000A</td>
			<td>加藤</td>
			<td>達夫</td>
			<td>信二</td>
			<td></td>
		</tr>
		<tr>
			<td>000B</td>
			<td>藤本</td>
			<td></td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td>001F</td>
			<td>三島</td>
			<td>敦</td>
			<td>陽子</td>
			<td>清美</td>
		</tr>
	</tbody>
</table>

#### 行持ち(縦持ち)テーブル

- **メリット**
  - データの整合性を保ちやすい
  - 頻繁なデータの追加・削除に有効
- **デメリット**
  - データの疎密性の高くなるケースが発生しやすい
  - データ検索・集計において複雑なクエリになりやすい

<table>
    <caption>扶養者(行持ち)</caption>
	<tbody>
		<tr>
			<th><u>社員ID</th>
			<th><u>枝番</th>
			<th>子</th>
		</tr>
		<tr>
			<td>000A</td>
			<td>1</td>
			<td>達夫</td>
		</tr>
		<tr>
			<td>000A</td>
			<td>2</td>
			<td>信二</td>
		</tr>
		<tr>
			<td>001F</td>
			<td>1</td>
			<td>敦</td>
		</tr>
		<tr>
			<td>001F</td>
			<td>2</td>
			<td>陽子</td>
		</tr>
		<tr>
			<td>001F</td>
			<td>3</td>
			<td>清美</td>
		</tr>
	</tbody>
</table>

<div style="page-break-before:always"></div>

#### 列持ち↔︎行持ちの変換

- **列持ち→行持ちの変換**
  - UNION ALLによってレコードをマージすれば出来上がるため、非常に簡単なロジック
- **行持ち→列持ちの変換**
  - GROUP BY句を用いてIDで集約し、CASE式を用いて列持ちを表現する。
  - GROUP BY句で集約しているため、MAX関数やMIN関数など集計関数を使う必要がある。

```sql
-- 列持ち→行持ちの変換
SELECT 社員ID, 1, 子1 FROM 扶養者(列持ち) WHERE 子1 IS NOT NULL
UNION ALL
SELECT 社員ID, 2, 子2 FROM 扶養者(列持ち) WHERE 子2 IS NOT NULL
UNION ALL
SELECT 社員ID, 3, 子3 FROM 扶養者(列持ち) WHERE 子3 IS NOT NULL

-- 行持ち→列持ちの変換
SELECT  社員ID,
        MAX(CASE WHEN 枝番=1 THEN 子 ELSE NULL END),
        MAX(CASE WHEN 枝番=2 THEN 子 ELSE NULL END),
        MAX(CASE WHEN 枝番=3 THEN 子 ELSE NULL END),
FROM 扶養者(行持ち)
GROUP BY 社員ID
```

### アドホックな集計キー
※アドホック(Ad Hoc): 特定の目的のための、その場限りの

#### 【課題】地方別に集計したいが地方を識別する情報がない

<table>
    <caption>都道府県</caption>
	<tbody>
		<tr>
			<th><u>県コード</th>
			<th>県名</th>
			<th>人口(万人)</th>
		</tr>
		<tr>
			<td>01</td>
			<td>北海道</td>
			<td>550</td>
		</tr>
		<tr>
			<td>02</td>
			<td>青森</td>
			<td>130</td>
		</tr>
		<tr>
			<td>03</td>
			<td>岩手</td>
			<td>133</td>
		</tr>
		<tr>
			<td>22</td>
			<td>静岡</td>
			<td>370</td>
		</tr>
		<tr>
			<td>23</td>
			<td>愛知</td>
			<td>740</td>
		</tr>
		<tr>
			<td>24</td>
			<td>三重</td>
			<td>185</td>
		</tr>
		<tr>
			<td>36</td>
			<td>徳島</td>
			<td>78</td>
		</tr>
		<tr>
			<td>37</td>
			<td>香川</td>
			<td>99</td>
		</tr>
	</tbody>
</table>

#### 【解決策1】地方を識別する変換テーブルの作成

- **メリット** メンテナンスが容易。
- **デメリット** 結合処理が必要になりパフォーマンスの考慮が必要。

<table>
    <tr>
        <td>
            <table>
            <caption>都道府県</caption>
            <tbody>
                <tr>
                    <th><u>県コード</th>
                    <th>県名</th>
                    <th>人口(万人)</th>
                </tr>
                <tr>
                    <td>01</td>
                    <td>北海道</td>
                    <td>550</td>
                </tr>
                <tr>
                    <td>02</td>
                    <td>青森</td>
                    <td>130</td>
                </tr>
                <tr>
                    <td>03</td>
                    <td>岩手</td>
                    <td>133</td>
                </tr>
                <tr>
                    <td>22</td>
                    <td>静岡</td>
                    <td>370</td>
                </tr>
                <tr>
                    <td>23</td>
                    <td>愛知</td>
                    <td>740</td>
                </tr>
                <tr>
                    <td>24</td>
                    <td>三重</td>
                    <td>185</td>
                </tr>
                <tr>
                    <td>36</td>
                    <td>徳島</td>
                    <td>78</td>
                </tr>
                <tr>
                    <td>37</td>
                    <td>香川</td>
                    <td>99</td>
                </tr>
            </tbody>
        </table>
        </td>
        <td>
            <table>
                <caption>都道府県-地方</caption>
                <tbody>
                    <tr>
                        <th><u>県コード</th>
                        <th>地方コード</th>
                    </tr>
                    <tr>
                        <td>01</td>
                        <td>01</td>
                    </tr>
                    <tr>
                        <td>02</td>
                        <td>01</td>
                    </tr>
                    <tr>
                        <td>03</td>
                        <td>01</td>
                    </tr>
                    <tr>
                        <td>22</td>
                        <td>02</td>
                    </tr>
                    <tr>
                        <td>23</td>
                        <td>02</td>
                    </tr>
                    <tr>
                        <td>24</td>
                        <td>02</td>
                    </tr>
                    <tr>
                        <td>36</td>
                        <td>03</td>
                    </tr>
                    <tr>
                        <td>37</td>
                        <td>03</td>
                    </tr>
                </tbody>
            </table>
        </td>
    </tr>
</table>

#### 【解決策2】ビューの利用

- **メリット** テーブルを隠蔽し、簡単に必要なデータ(地方単位の集計)を取得可能。
- **デメリット** 多段ビューの場合はパフォーマンス劣化につながるため注意が必要。

#### 【解決策3】GROUP BY句の活用

- **メリット** 汎用性があり、WHERE、GROUP BY、HAVING、ORDER BYそれぞれで記述可能。
- **デメリット** SQLのスキルセットがある程度必要。

```sql
SELECT 
    SUM(人口) as 人口, 
    CASE WHEN 県コード IN ('01', '02', '03') THEN '01'
        WHEN 県コード IN ('22', '23', '24') THEN '02'
        WHEN 県コード IN ('36', '37')       THEN '03'
        ELSE NULL 
    END AS 地方コード
FROM 都道府県
GROUP BY 地方コード
```

<div style="page-break-before:always"></div>

### 多段ビュー

#### 【基礎】ビューのアクセスは「2段階」

- ユーザ→ビューは1回目、ビュー→テーブルは2回目のSELECTになる。
- **メリット** 基底テーブルを隠蔽できる。
- **デメリット** 単一のビューであれば良いが、複数のビューやテーブルを参照する場合は多段ビューになり、パフォーマンスに悪影響を与える。

<img src="images/ビュー.png" width=80%>

#### 多段ビューの悪影響

- **悪影響1** 階層的にデータ参照が行われるため<font color=red>パフォーマンスが劣化</font>する。
- **悪影響2** テーブルとビューの依存関係がわかりにくくなり、<font color=red>仕様が複雑で管理が困難</font>。

<img src="images/多段ビュー.png" width=80%>

<div style="page-break-before:always"></div>

### データクレンジング

<img src="images/データクレンジング.png">

<b>データクレンジングとは、<font color=red>業務で利用されているデータをデータベースに登録できる状態にすること</font></b>である。データクレンジングができていないとバッドノウハウやグレーノウハウにつながるため、論理設計に先立って行う必要がある。具体的には、データフォーマットの評価が挙げられる。これまでのことを踏まえると、<b><u>①データクレンジングは論理設計に先立って行われ、②論理設計は物理設計に先立って行われる</u></b>。
　データクレンジングでは、データフォーマットの評価を行うが、評価の際には「一意キーの特定」と「名寄せ」の2つが実施される。

#### 【作業1】一意キー(ユニークキー)の特定

一意キーの特定について、人や場所、予約や履歴などを一意に識別できる値が必要であり、固定長文字列のIDやコードを用いることを意識しておくことが重要である。

#### 【作業2】名寄せ

まず、**名寄せとは、似通った名前を寄せ集めて統合する**という標準化作業の一種であり、<u>金融機関の統廃合などで口座を統合する際に行われてきた作業</u>である。**名寄せの原因は「フリーハンド」により複数表記が許されているから**であり、負の遺産(汚いデータ)になってしまう。データベースにおいて、名寄せを疎かにすると「ダブルマスタ」につながってしまう。
　名寄せの際に異なる2つのデータの値が同一であるかどうかを判断する指標として、「①別の情報と組み合わせられるかどうか」と「②出現頻度の高い情報かどうか」の2つが挙げられる。まず、①について、これは名寄せの対象となるデータが別の情報と組み合わせることで情報の確度を高められるかどうかということである。例えば、人の名前が名寄せの対象となった場合、住所(別の情報)と組み合わせて名前の確度を高められる。次に、②について、これは会社名などの重複がないデータを用いて、名寄せするということである。基本的に、会社名は所定の役所で法人登録を行うため、重複がない。そのため、会社名が同じレコードで似通ったレコードを探せば、名寄せがしやすくなるはずである。

<div style="page-break-before:always"></div>

### 演習問題

#### データが満たすべき条件(ビジネスロジック)をテーブルの制約ではなく、アプリケーションコードによって実装することは一般的に行われている。そこで、①ビジネスロジックをプログラムとテーブルの制約のどちらで実装するのか、と②ビジネスロジックをデータベースの「トリガー」で実装することの是非、の2つについて考えよ。

##### 回答

①について、ビジネスロジックをテーブルの制約で実装する場合、プログラムでの実装と違い2つの困難がある。
　1つ目は複雑なビジネスロジックを実装できないということがある。例えば、「テーブル$A$の列$a$はテーブル$B$の列$b$より小さい」という制約がある場合、これをテーブルの制約として実装するのは難しい。<u>CHECK制約により100以下の値であるかどうかを判断することは容易であるが、テーブルを横断して値を比較することは難しい</u>。<b>データベース側(インフラ)とプログラム側(アプリケーション)でそれぞれ実装するという折衷案を採用した場合、<font color=red>管理が難しいだけでなく、実装箇所がわからなくなってしまう</font>ことから、どちらかに絞ることが肝要</b>である。
　2つ目はエラーハンドリングが難しいということである。例えばINSERT処理でエラーが出た場合、データベース側ではユーザで定義できるエラー処理が限られており、「不親切」な実装になってしまう。これにより、<u>「システム管理者に連絡してください。」の一点張りで、どこをどう間違えたのかわからないシステムになってしまう</u>。データベース側では、主キーやNOT NULL制約など簡単には変化しない永続的なルールを実装することが望ましい。
　以上の2点から<b>主キー、参照生合成制約、NOT NULL制約というRDBにとって基本的なルールはDB側で実装し、それ以外のビジネスロジックはプログラム側で実装する。</b>決して正解ではないが、一つの指針になる。

②について、トリガーは使うべきではなくストアドプロシージャを用いるべき、ということが考えられる。ストアドプロシージャはユーザーが明示的に実行しないと実行されないが、トリガーはテーブルの変更（INSERT、UPDATE、DELETE）を契機として自動的に実行（発射）される。このトリガーは使うべきではないものであり、理由は以下の4つが挙げられる。

1. 実装ごとに文法がバラバラで統一性がない。
2. オプティマイザによる最適化を受けられない。
3. エラーハンドリングが困難。
4. アプリケーション以外の更新でも発射されるため、開発が困難。


#### DBMSでは「一時テーブル」という機能を用意している。この機能について調査し、使うことの是非について考えよ。

##### 回答

|  | データ鮮度 | パフォーマンス | データを保持するか | データの格納領域 |
| -- | -- | -- | -- | -- |
| ビュー |高<br>(リアルタイム) | 低 | しない | ー |
| マテリアライズド<br>ビュー |中<br>(更新タイミング次第) | 高 | 永続的に保持 | 任意<br>(通常はデータファイル) |
| 一時テーブル | 中<br>(更新タイミング次第) | 中(物理設計と<br>統計情報に注意) | 一時的に保持 | 一時ファイル |